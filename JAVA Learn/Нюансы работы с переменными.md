## Константы

> [!tip] Важно
>  Константы — переменные, значения которых **нельзя** изменять.

Итак, как же объявить неизменяемую переменную (константу) в Java? Для этого есть ==**специальное ключевое слово**== — `final`. Выглядит создание неизменяемой переменной так же, как и создание обычной, только перед типом переменной нужно ==написать слово== `final`

![[Pasted image 20240325170149.png]]

Если вы попытаетесь ==присвоить== `final`-переменной другое значение, ваша программа ==просто не скомпилируется==.
`final`-==**переменную обязательно нужно инициализировать при объявлении**== (присвоить ей значение). У этого правила есть одно исключение: можно ==перенести инициализацию переменной класса в конструктор==.
Чтобы уменьшить количество ключевых слов, разработчики Java используют слово `final` не только для объявления констант. `final` также может быть указан ==перед методом и даже классом==. Методы, объявленные как `final`, ==**нельзя переопределять (override)**==, а от класса, объявленного как `final`, ==**нельзя наследоваться**==.
Модификатор `final` можно добавлять перед любыми переменными: ==локальными, параметрами, полями класса и статическими переменными==.
Обратите внимание, что `final` — это всего лишь ==защита от изменения переменной==. Если переменная ==хранит ссылку на объект, объект все-таки менять **можно==**.

![[Pasted image 20240325170837.png]]
## Глобальные константы
Если вы решите объявить в своей программе ==**глобальные константы**==, для этого нужно создать **статические** переменные класса, а также сделать их `public` и `final`. Для имен таких переменных существует ==специальный стиль написания==: ==**они пишутся заглавными буквами, а в качестве разделителя слов выступает символ подчеркивания**==.

![[Pasted image 20240325170951.png]]
## Затенение переменных
Как мы уже говорили раньше, нельзя в одном методе создать несколько локальных переменных с одинаковыми именами. В разных методах — можно.
Но вот то, чего вы скорее всего не знаете: ==разрешается, чтобы у переменных класса и локальных переменных метода были одинаковые имена==.

![[Pasted image 20240325171225.png]]

В методе `add` мы объявили локальную переменную `sum`, и она до конца действия метода ==перекрывает== (или еще говорят **затеняет**) ==собой переменную класса== `sum`.
Если переменную класса **затеняет** локальная переменная, в методе все-таки ==существует способ обратиться к переменной класса==. Для этого нужно ==перед ее именем написать ключевое слово== `this`:

![[Pasted image 20240325171412.png]]

![[Pasted image 20240325171523.png]]

Везде переменные `count` и `sum` ==доступны как с ключевым словом== `this`, ==так и без него==. В тех строках, где локальная переменная `sum` **затеняет** переменную класса `sum`, доступ к переменной класса `sum` **==возможен только при использовании==** `this`.

Если затеняется не **просто переменная класса**, а ==**статическая переменная класса**==, обращаться к ней **нужно не через** `this`, а ==**через имя класса**==:

![[Pasted image 20240325171803.png]]

![[Pasted image 20240325171826.png]]

Везде статические переменные `count` и `sum` доступны ==как с префиксом в виде имени класса== `Solution`, ==так и без него==. В тех строках, где локальная переменная `sum` **затеняет** переменную класса `sum`, доступ к переменной класса `sum` ==**возможен только при использовании префикса**== `Solution`.

## Переменные внутри цикла `for`
Есть еще место, где особенным образом объявляется переменная — это **цикл `for`**.
Если вы помните, обычно у цикла `for` в круглых скобках объявляется переменная-счетчик. И какова же будет видимость этой переменной? Она ведь не находится в теле цикла — значит, весь метод? Или всё-таки нет?
**Правильный ответ такой**: ==переменная==, ==объявленная в заголовке== **цикла `for`**, ==видна только в **теле цикла** и в **заголовке цикла== `for`**.

![[Pasted image 20240325175707.png]]

Поэтому вы всегда ==можете в своем коде последовательно написать несколько циклов с переменной-счетчиком с одинаковым именем — **проблем не будет==**.

![[Pasted image 20240325175741.png]]
