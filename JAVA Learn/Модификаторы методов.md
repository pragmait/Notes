## Модификаторы доступа
Перед каждым методом программист может указать так называемые модификаторы доступа. К ним относятся ключевые слова: `public`, `protected`, `private`.
Эти «модификаторы доступа» позволяют ограничивать доступ к методу из других классов.
Например, если перед объявлением метода написать ключевое слово `private`, этот метод можно будет вызывать только из того же класса, в котором он объявлен. Ключевое слово `public` разрешает обращение к помеченному методу из любого метода любого класса.
Всего таких модификаторов 3, а типов доступа к методу — 4, ведь отсутствие модификатора доступа тоже что-то значит.

![[Pasted image 20240323200554.png]]

**1. Модификатор `public`.**
К методу (переменной или классу), помеченному модификатором `public`, ==**можно обращаться из любого места программы**==. Это самая **высокая** степень ==открытости== – **никаких ограничений нет**.

**2. Модификатор `private`.**
К методу (переменной или классу), помеченному модификатором `private`, **==можно обращаться только из того же класса, где он объявлен==**. Для всех остальных классов помеченный метод (или переменная) – ==невидимы== и «как бы не существуют». Это самая **высокая** степень ==закрытости== — только свой класс.

**3. Без модификатора (модификатор по умолчанию).**
Если метод (или переменная) не помечены никаким модификатором, считается, что они помечены «**==модификатором по умолчанию==**». Переменные или методы с таким модификатором (т.е. вообще без какого-нибудь) **==видны всем классам пакета, в котором они объявлены==**. ==**И только им**==. Этот ==модификатор еще иногда называют ==`package`, намекая, что доступ к переменным и методам открыт для всего пакета, в котором находится их класс

**4. Модификатор `protected`.**
Если метод помечен модификатором `protected`, ==**к нему можно обращаться из того же класса, того же пакета и классов наследников (классов, унаследованных от класса, в котором объявлен метод)**==. Эту тему разберем подробнее в квесте Java Core.

До конца квеста Java Syntax вы можете всем своим методам (а также классам и переменным класса) указывать модификатор `public`. Другие модификаторы вам понадобятся, когда мы начнем активно изучать ООП.

**Зачем нужны модификаторы доступа?**
Все дело в больших проектах, которые пишут десятки и сотни программистов одновременно.
Иногда бывают ситуации, когда программист хочет разделить слишком большой метод своего класса на части и вынести часть кода во вспомогательные методы. Но вместе с тем он не хочет, чтобы другие программисты вызывали эти вспомогательные методы, т.к. тогда код его класса может работать неправильно.
Вот и придумали такие модификаторы доступа. Пометил вспомогательный метод словом **private**, и никакой код кроме вашего класса не сможет увидеть ваш вспомогательный метод.
## Ключевое слово `static`
Ключевое слово `static` **==превращает метод в статический==**. Что это такое, мы рассмотрим позднее, а сейчас просто запомним пару фактов про статические методы.

**Факт 1. Статический метод не привязан ни к какому объекту**, но относится к классу, в котором объявлен. Чтобы вызвать статический метод, нужно написать:

![[Pasted image 20240323204032.png]]

Примеры статических методов:

![[Pasted image 20240323204052.png]]

==Имя класса== перед ==именем статического метода== ==**можно не писать, если вы вызываете статический метод изнутри — из того же класса**==. 

**Факт 2. Статический метод не может обращаться к нестатическим методам** его же класса. ==**Статический метод может обращаться только к статическим методам**==. Поэтому все методы, которые мы хотим вызвать из метода `main`, мы объявляем статическими.
## Ключевое слово `throws`
Есть еще одно ключевое слово, которое вы, вероятно, видели рядом с объявлением метода — это слово `throws`. Оно, в отличие от модификаторов доступа и ключевого слова `static`, ==**размещается после параметров метода**==:

![[Pasted image 20240323204634.png]]

Можно сказать, что в методе, помеченном словом **throws**, ==могут возникать ошибки (исключения) типа== `Exception` (и унаследованных от него классов). Если в классе могут **возникнуть ошибки нескольких типов**, ==**нужно перечислить все типы через запятую**==.
## Метод `main`
Строка, в которой объявляется метод, со всеми модификаторами, будет влиять на то, как этот метод будет вызываться из других классов и методов. Результат какого типа он будет возвращать и какие возможны ошибки при его работе.
Такая строка называется объявлением метода и имеет общий вид:

![[Pasted image 20240323205209.png]]

Где `модификаторы доступа` — это `public`, `protected`, `private` или ничего;
`static` ставится, если метод статический (отсутствует для нестатических методов)
`тип` — тип результата функции (`void` если результат отсутствует)
Теперь вы скорее всего понимаете, что значат все ключевые слова при объявлении метода `main`:

![[Pasted image 20240323205312.png]]
Доступ к методу `main()` возможен из любого класса, об этом говорит слово `public`.
Метод статический (его можно явно вызвать в виде `Solution.main()`).
Метод `main` не возвращает никакого результата. Тип результата — `void` (пустой тип/заглушка)
Метод `main` принимает параметры(!): массив строк. И название `args` намекает на «аргументы программы». При запуске программы в нее можно передать параметры — массив строк. Они и будут содержаться в массиве `args` метода `main()`.
В методе `main()` могут возникать необработанные ошибки типа `Exception` (или его наследники).