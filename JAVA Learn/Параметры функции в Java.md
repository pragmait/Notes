> [!tip] Важно
> ==Имя метода и типы его параметров называются **сигнатурой метода**. Пример: `sum(int, int)`==

## Передача параметров

![[Pasted image 20240303173200.png]]

Где `имя` — это уникальное имя метода, а `код метода` — это команды, из которых состоит метод. А `параметры` — это ==параметры метода, перечисленные через запятую==. Давайте лучше распишем этот шаблон более детально:

![[Pasted image 20240303173252.png]]

Привет:

![[Pasted image 20240303194413.png]]

> [!tip] Важно
> Если мы не хотим, чтобы у метода были параметры, просто оставляем круглые скобки пустыми.

Параметры — это ==специальные переменные метода==. С их помощью в метод можно передавать различные значения при его вызове.
Каждый раз при вызове метода его переменным-параметрам ==присваиваются переданные значения==, и только **потом** начинают выполняться ==команды внутри метода.==
## Аргументы метода

> [!tip] Важно
> Те значения, которые передаются в метод, при его вызове принято называть **==аргументами метода==**.
> Параметры метода — это ==именно переменные, которым присваиваются определенные значения при вызове метода==. Сами же значения `"Привет"`, `"Пока"`, `10` и `20` называются **==аргументами метода==**.

## Конфликт имен переменных при вызове метода

![[Pasted image 20240304002152.png]]

Обратите внимание на две вещи:
**Первое**: у нас есть переменные с одинаковыми именами в разных методах. Это **разные** переменные (мы их специально раскрасили в разные цвета). Все работает так же, как и в предыдущем примере, когда переменные в методе `main` назывались `str` и `n`.
**Второе**: при вызове метода никакого волшебства не происходит. Переменным-параметрам просто присваиваются значения аргументов. Независимо от того, это конкретные числа, строки, переменные или выражения.
После переименования переменных в методе main ничего не поменялось. Это как были **разные переменные в разных методах**, так и остались. Никакой магической связи между переменными `text` и `text` нет.

## Передача ссылок в методы

![[Pasted image 20240304002256.png]]

Произойдет ровно то же самое: переменная-параметр `data` будет содержать ссылку на тот же контейнер, что и переменная `months`. При вызове метода просто произойдет присваивание `data = months`.
А раз обе переменные ссылаются на один и тот же контейнер целых чисел, то метод `printArraySum` может не просто читать значения из массива, но и менять их!
Например, мы можем написать свой собственный метод, который заполняет двумерный массив одинаковыми значениями. Вот как он мог бы выглядеть:

![[Pasted image 20240304002343.png]]

##  Методы с одинаковыми именами
Стандарты Java требуют, чтобы у всех методов внутри одного класса были уникальные имена. Т.е. невозможно объявить в одном классе два одинаковых метода.

> [!tip] Важно
> Только вот при сравнении методов на одинаковость учитываются ==**не только имена**, но и **типы параметров**==! Причем ==имена переменных-параметров не учитываются==.

![[Pasted image 20240304002533.png]]

Почему же одни методы считаются одинаковыми, а другие — разными? И почему не учитываются имена переменных-параметров при определении уникальности метода?
Зачем вообще нужна уникальность? Все дело в том, что когда компилятор компилирует вашу программу, он должен точно знать, какую именно функцию/метод вы вызываете в определенном месте.
Например вы пишете `System.out.println("Привет")` Компилятор умный, и он легко сделает вывод, что тут вызывается метод `println()` с параметром типа `String`.
А если вы напишете `System.out.println(1.0)`, компилятор увидит тут вызов метода `println()` с параметром типа `double`.
Компилятор следит, чтобы при вызове метода типы аргументов и параметров совпадали, а на имя аргумента не обращает никакого внимания. В Java имена переменных-параметров никак не помогают компилятору определить вызываемый метод. Поэтому и не учитываются при определении уникальности метода.
==Имя метода и типы его параметров называются **сигнатурой метода**. Пример: `sum(int, int)`==
Каждый класс должен иметь не методы с уникальными именами, а методы с уникальными сигнатурами.