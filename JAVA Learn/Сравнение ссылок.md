## Сравнения
==Целые числа сравнивать очень легко — просто используйте==  " == "  и все. Чтобы сравнить **вещественные числа**, вам уже ==придется сравнивать их разность== (вернее, модуль разности) с каким-нибудь очень маленьким числом.

==Сравнение строк еще сложнее.== А всё потому, что, во-первых, **==строки — это объекты==**, а во-вторых, в зависимости от ситуации программисту часто хочется, чтобы сравнение строк проходило чуть-чуть иначе (учитывая или не учитывая определенные факторы).

## Расположение строк в памяти
Как вы уже успели увидеть, строки в памяти хранятся не так, как целые и вещественные числа:

> [!tip] Важно
> Для хранения строк используется ==**два блока памяти**==: **один блок хранит сам текст** (его размер зависит от размера текста), а второй (==размером 4 байта==) **хранит адрес первого блока**.

Хотя опытный программист в такой ситуации скажет что-то вроде «Переменная `str` типа `String` хранит ссылку на объект типа `String`».

![[Pasted image 20240129235101.png]]

## Присваивание ссылок на строки
Выгода такого подхода становится очевидной, если ==вам нужно присвоить одной строковой переменной другую строковую переменную==. Пример:

![[Pasted image 20240129235346.png]]

А вот что в результате будет в памяти:

![[Pasted image 20240129235406.png]]

В результате этой операции присваивания объект `String` ==так и останется, где был==, а в переменную `message` ==скопируется только его адрес== (ссылка на объект).

## Работа со ссылками и объектами
А вот если вы решите преобразовать строку к верхнему регистру (заглавные буквы), Java-машина сделает все правильно: у вас будут два объекта типа `String`, и переменные `text` и `message` будут хранить ссылки: каждая на свой объект.

![[Pasted image 20240129235648.png]]

А вот что в результате будет в памяти:

![[Pasted image 20240129235711.png]]

Обращаю ваше внимание, что метод `toUpperCase()` ==не меняет ту строку, у которой он был вызван. Вместо этого он создает новую строку (новый объект) и возвращает ссылку на него==.

Или еще более интересный пример. Скажем, вы решили передать строку в объект типа `Scanner` (чтобы он читал значения из нее).

![[Pasted image 20240130000126.png]]

Вот как это все будет храниться в памяти:

![[Pasted image 20240130000156.png]]

При этом объект типа `String` как был ==в памяти в единственном экземпляре, так там и хранится== — везде передаются и хранятся **только ссылки на него**.

## Сравнение ссылок на объекты типа `String`
Для сравнения строковых переменных можно использовать **==два оператора==**: ` == ` (равно) и ` != ` (не равно). ==Операторы «больше», «меньше», «больше либо равно» использовать нельзя — компилятор не допустит.==

Но есть интересный нюанс: что у нас хранится в строковых переменных? ==Правильно: адреса (ссылки) на объекты. Вот эти самые адреса сравниваться и будут==:

![[Pasted image 20240130000620.png]]

![[Pasted image 20240130000640.png]]

Переменные `message` и `text` хранят адрес (ссылку) одного и того же объекта. А вот переменные `s1` и `s2` хранят ссылки на очень похожие объекты, но все-таки не на один и тот же объект.
И если вы сравните в коде эти 4 переменные, получите вот такой результат:

![[Pasted image 20240130000716.png]]