## Класс `Arrays`
Как мы уже раньше говорили, массивы — очень полезная и часто используемая вещь в программировании.

Создатели Java очень скоро заметили, что Java-программисты часто пишут один и тот же код при работе с массивами. Например: «скопировать часть массива в другой массив», «заполнить все ячейки массива одинаковыми значениями», «вывести содержимое массива в удобно читаемом виде на экран» и т.п.

Поэтому они сделали ==специальный класс== – `Arrays` (полное имя `java.util.Arrays`), в который поместили самые популярные действия при работе с массивами.

## Метод `Arrays.toString()`
И первый метод, который мы рассмотрим, будет называться `Arrays.toString()`. Но для начала немного предыстории.

У каждого массива в Java есть метод `toString()`, который возвращает «текстовое представление массива». Получить текстовое представление массива можно с помощью такой конструкции:

![[Pasted image 20240223002748.png]]

Где `имя` — это имя переменной-массива, а `str` — это имя переменной, в которую сохранится строковое представление массива.

Но если вы попробуете вывести массив на экран с помощью метода `System.out.println(имя)`, скорее всего увидите что-то типа:

![[Pasted image 20240223002808.png]]

Первая буква `I` означает, что это массив ==типа== `int`, а символы после `@` – ==адрес массива в памяти==. С одной стороны, переменная-массив именно эту информацию и хранит, а с другой — мы ожидали иное, правда?

Хотелось бы увидеть значения, которые есть в массиве! И вот для того, чтобы увидеть именно значения массива, и придумали метод `Arrays.toString()`. Его вызов выглядит так:

![[Pasted image 20240223002853.png]]

![[Pasted image 20240223003015.png]]

## Метод `Arrays.deepToString()`
Но если вы с помощью метода `Arrays.toString()` попробуете преобразовать в строку (вывести на экран) двумерный массив, увидите кое-что знакомое:

![[Pasted image 20240223003221.png]]

А все дело в том, что в ячейках двумерного массива хранятся ссылки на одномерные массивы. А одномерные массивы как преобразовываются в строку? Именно так, как вы видите выше.

И что же делать? Как нам получить правильное отображение двумерного массива?

Для этого у класса `Arrays` есть еще один специальный метод — `deepToString()`. Вызов его выглядит так:

![[Pasted image 20240223003238.png]]

В этот метод можно передать двумерный, одномерный, трехмерный и вообще массив любой размерности, и он всегда будет отображать элементы массива.  
**Обрати внимание:** метод `Arrays.deepToString()` ==не работает с одномерными массивами примитивов== (например, `int[]`).

Примеры:

![[Pasted image 20240223003312.png]]

## Метод `Arrays.equals()`
С выводом массивов на экран мы разобрались, а что насчет сравнения массивов?
Для сравнения строк у нас были методы `equals` и `equalsIgnoreCase`, а какие методы есть у массивов?

Хорошая новость: ==у массивов есть метод== `equals`, и плохая новость — он не сравнивает содержимое массивов. Метод `equals` у массивов делает то же самое, что и оператор  " == " – сравнивает ссылки.

![[Pasted image 20240223003612.png]]

И что же делать? Как сравнить массивы по их содержанию?

И опять нам на выручку приходит класс `Arrays`, а вернее, его метод `Arrays.equals()` Выглядит его вызов так:

![[Pasted image 20240223003640.png]]

Метод возвращает `true` (истина), если ==массивы равной длины и их элементы равны==. Иначе возвращает `false` (ложь).

![[Pasted image 20240223003711.png]]

## Метод `Arrays.deepEquals()`

И как вы уже, наверное, догадываетесь, метод `Arrays.equals` для двумерных массивов будет работать неправильно: он работает с двумерным массивом как с одномерным, элементы которого — адреса одномерных массивов.

Поэтому, чтобы правильно сравнивать многомерные массивы (`n=1, 2, 3, ...`), придумали метод `Arrays.deepEquals()`. Выглядит его вызов так:

![[Pasted image 20240223010448.png]]

Метод возвращает `true` (истина), ==если массивы равной длины и их элементы равны==. Иначе возвращает `false` (ложь). Если элементы внутри массива — тоже массивы, для их сравнения используется метод `Arrays.deepEquals()` и т.д.

Примеры:

![[Pasted image 20240223010512.png]]

## Метод `Arrays.fill()`
Очень часто у Java-программистов при работе с массивами возникает задача: заполнить массив одинаковыми значениями. Можно, конечно, написать цикл и просто в цикле присвоить каждой ячейке массива определенное значение:

![[Pasted image 20240223010625.png]]

А можно просто вызвать метод `Arrays.fill()`, который делает точно то же самое: заполняет переданный массив переданным значением. Вот как это выглядит:

![[Pasted image 20240223010654.png]]

И код из примера выше можно сделать немного компактнее и понятнее:

![[Pasted image 20240223010716.png]]

А еще с помощью метода `Arrays.fill()` можно заполнить определенным значением не весь массив, а его часть:

![[Pasted image 20240223010811.png]]

==Где первый и последний — это номера первой и последней ячеек, которые нужно заполнить==.

> [!tip] Важно
> По старой доброй традиции Java, последний элемент не входит в диапазон.

Пример:

![[Pasted image 20240223011003.png]]

> [!tip] Важно
> Метод `Arrays.fill()` работает только с одномерными массивами. Если в него передать двумерный массив, он будет обработан как одномерный, со всеми вытекающими последствиями.

## Метод `Arrays.copyOf()`

Как вы уже знаете, размер контейнера массива после его создания поменять нельзя.

А если очень хочется?

Ну, если очень хочется, ==то можно==:

- Создать новый массив нужной длины
- Скопировать в него все элементы из первого массива.

Именно это, кстати, и делает метод `Arrays.copyOf()`. Вот как выглядит его вызов:

![[Pasted image 20240223011117.png]]

Этот метод ==**не меняет существующий массив**==, вместо этого он ==**создает новый массив**== и копирует в него элементы старого массива.

> [!tip] Важно
> ==Если элементы не поместились (длина меньше длины существующего массива), то лишние значения игнорируются==.
> Если длина нового массива больше длины старого, ячейки заполняются нулями.

Пример:

![[Pasted image 20240223011353.png]]

## Метод `Arrays.copyOfRange()`
А что делать, если вы хотите получить массив длиной 5 из массива длины 10, но чтобы в нем были не первые 5 элементов, а 5 последних?

Именно для этого случая вам пригодится еще один метод класса `Arrays` – метод `Arrays.copyOfRange()` Вот как выглядит его вызов:

![[Pasted image 20240223011500.png]]

Этот метод тоже ==создает новый массив==, но заполняет его данными ==из произвольного места исходного массива==. Где первый и последний — это номера первой и последней ячеек, которые должны быть в новом массиве.

> [!tip] Важно
> По старой доброй традиции Java, последний элемент не входит в диапазон.

Пример:

![[Pasted image 20240223011631.png]]

## Метод `Arrays.sort()`
Ну и самое вкусное — **==сортировка==**. В программировании сортировать массивы приходится очень часто. Три самых частых действия при работе с массивами:

- Сортировка массива
- Поиск минимального (или максимального) элемента массива
- Определение индекса элемента в массиве (поиск элемента в массиве)

И именно поэтому разработчики Java включили в класс `Arrays` метод `sort()`. Вот как выглядит его вызов:

![[Pasted image 20240223011731.png]]

Этот метод ==сортирует переданный массив по **возрастанию==**.

Пример:

![[Pasted image 20240223011810.png]]

Отлично, да? Вызвал один метод, и вот у вас еще отсортированный массив. Красота.

Кстати, сортировать ==можно не только весь массив, но и часть массива==. Вот как выглядит его вызов:

![[Pasted image 20240223011917.png]]

Где **первый** и **последний** — это номера первой и последней ячеек, которых должна коснуться сортировка.

> [!tip] Важно
> По старой доброй традиции Java, последний элемент не входит в диапазон.

![[Pasted image 20240223011951.png]]

> [!tip] Важно
> В Java для сортировки массивов используется **==самый быстрый алгоритм сортировки==— ==QuickSort==**. Скорость его сортировки зависит от размера массива и рассчитывается по формуле N*Log(N)*.
> Сортировка массива из 1000 элементов будет содержать около 3_000 сравнений ячеек массива. Сортировка массива из миллиона элементов будет содержать около 6 миллионов сравнений.

## Метод `Arrays.binarySearch()`

Ну и последний из самых интересных методов класса `Arrays` умеет искать заданное значение в массиве. Это не обычный поиск, а так ==называемый бинарный поиск==. Суть его заключается вот в чем:

- Предварительно массив сортируется
- Затем средний элемент массива сравнивается с искомым (с тем, который мы ищем).
- Если искомый больше среднего, поиск продолжается в правой половине массива.
- Если искомый элемент меньше среднего, поиск продолжается в левой половине массива

Благодаря тому, что массив отсортирован, можно за одно сравнение отбросить половину массива. Затем на следующем шаге отбросить еще половину и т.д.

Такой подход делает бинарный поиск очень быстрым. В массиве из миллиона(!) элементов он может найти индекс нужного элемента всего за 20 сравнений. Минусом такого подхода является то, что массив предварительно нужно отсортировать, а сортировка тоже занимает время.

Вот как выглядит его вызов:

![[Pasted image 20240223012334.png]]

Где `имя` — это имя массива, который ==нужно передать уже отсортированным== (например, с помощью функции `Arrays.sort()`). `значение` — это тот элемент, который ищется в массиве. Метод возвращает результат — индекс искомого элемента в массиве (номер ячейки массива).

Примеры:

![[Pasted image 20240223012525.png]]

Если искомых элементов в массиве **несколько**, ==просто вернется номер одного из них (нет гарантий, что это будет, допустим, самый первый или наоборот — самый последний из одинаковых элементов)==.

Если элемент в массиве ==**не найден, индекс будет отрицательным.**==

## Ссылка на Oracle документация по классу `Arrays`
Если вам очень интересно, полностью информацию про класс `Arrays` и все его методы вы можете прочитать в официальной документации на сайте Oracle:

[https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Arrays.html](https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Arrays.html)

Можете почитать, например, про методы `Arrays.mismatch()` и `Arrays.compare()`. Может, найдете в них для себя что-нибудь полезное.

И пусть вас не смущает количество методов – там у каждого метода есть 5-10 копий, которые отличаются только типом параметров.